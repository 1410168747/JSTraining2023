## 答案

### `i1`

#### 問い

```js
async function i1() {
  // NOTE: any で1つ Promise が解決された時に他の Promise はどうなるだろうか
  let v = 0;

  v = await Promise.any([
    wait1().then(() => 42),
    wait2()
      .then(() => (v = 100))
      .then(() => 0),
  ]);

  log(v);
  await wait2();
  log(v);
}
```

#### 予想

1秒後に`42`が表示されて、その1秒後に`100`が表示される。

`wait1()`関数の返す`Promise`が1秒で満たされ、その後即座に`()=>42`も満たされるため、`v`はこの時点で42となる。
`wait1()`関数の返す`Promise`が満たされるのは2秒かかるので、`await wait2()`呼び出し前の`v`は42である。`await wait2()`が満たされる時には、`then(() => (v = 100))`のコールバックも呼び出し済なので、`v`は100になる

```text
42
100
```

となる。

#### 結果

予想通り

### `i2`

#### 問い

```js
async function i2() {
  const v = await Promise.all([
    wait3().then(() => {
      logA();
      return "A";
    }),
    wait2().then(() => {
      logB();
      return "B";
    }),
    wait1().then(() => {
      logC();
      return "C";
    }),
  ]);
  log(v);
}
```

#### 予想

1秒後に`C`が出力される。`C`が出力された1秒後に`B`が出力される。`B`が出力された1秒後に`A`が出力される。
Aが出力された後即座に、`[A,B,C]`が出力される。

`Promise.all()`メソッドの戻り値は

> 履行された値は、完了順に関係なく、渡されたプロミスの順番で、履行された値の配列となります。

#### 結果

予想通り

```text
C
B
A
[ 'A', 'B', 'C']
```

### `i3`

#### 問い

```js
async function i3() {
  // NOTE: all で引数の1つが失敗すると他の Promise はどうなるだろうか
  let v = 42;
  try {
    await Promise.all([
      wait3().then(() => {
        v = 0;
        errX();
      }),
      wait2().then(() => {
        logB();
        return "B";
      }),
      wait1().then(() => {
        errY();
      }),
    ]);
  } catch (e) {
    log(e.message);
    log(v);
    await wait3();
    log(v);
  }
}
```

#### 予想

`i3()`関数呼び出しの1秒後に`errY()`関数で失敗し、エラー理由`Y`がログに出力される。
その直後, `v`の値が出力される。この時点で`v`は`42`である。
`i3()`関数呼び出しの2秒後(`42`の出力から1秒後)に`B`が出力される。
`i3()`関数呼び出しの3秒後(`B`の出力から1秒後)に`v`が`0`になる。その直後`errX()`関数で失敗し、`0`が出力される。

```
Y   // i3()呼び出しから約1秒後
42  // 上行の直後
B   // 上行の約1秒後
0   // 上行の約1秒後
```

#### 結果

`0`が出力されるのがi3()呼び出しから約4秒後だった

```
Y   // i3()呼び出しから約1秒後
42  // 上行の直後
B   // 上行の約1秒後
0   // 上行の約2秒後
```

### `i4`

#### 問い

```js
async function i4() {
  // NOTE: i5, i6 との比較用 (直列に処理を実行したいものとする)
  let p = Promise.resolve(null);
  for (let i = 0; i < 5; ++i) {
    p = p.then(() => wait((5 - i) * 1000).then(() => log(i)));
  }
  return p.then(() => log("COMPLETED"));
}
```

#### 予想

```
0 // i4()呼び出しから約5秒後
1 // 上行の約4秒後
2 // 上行の約3秒後
3 // 上行の約2秒後
4 // 上行の約1秒後
COMPLETED // 上行の直後
```

#### 結果

予想通り

```
Y   // i3()呼び出しから約1秒後
42  // 上行の直後
B   // 上行の約1秒後
0   // 上行の約2秒後
```

### `i5`

#### 問い

```js
async function i5() {
  // NOTE: このコードは期待通りの挙動をすると考えられるだろうか？(典型的なミス)
  let p = Promise.resolve(null);
  for (let i = 0; i < 5; ++i) {
    p = p.then(wait((5 - i) * 1000).then(() => log(i)));
  }
  return p.then(() => log("COMPLETED"));
}
```

#### 予想

1つめの`then()`の引数が`wait()`メソッドの戻り値である`Promise`オブジェクトあり、コールバックではないので、コールバックが実行されるタイミング(このロジックでは`then()`メソッド呼び出しとほぼ同時)にエラーが発生する。そのため、以後の`then()`メソッドは全てスキップされる。さらに、一連の _Promiseチェーン_ には`catch()`メソッドがないため、エラーは処理されない。

#### 結果

```
COMPLETED
4 // 上行の約1秒後
3 // 上行の約1秒後
2 // 上行の約1秒後
1 // 上行の約1秒後
0 // 上行の約1秒後
```

### `i6`

#### 問い

```js
async function i6() {
  return Promise.all(
    [0, 1, 2, 3, 4].map((i) => wait((5 - i) * 1000).then(() => log(i)))
  ).then(() => log("COMPLETED"));
}
```

#### 予想

i6から1秒後に4が出る
i6から2秒後に3が出る
i6から3秒後に2が出る
i6から4秒後に1が出る
i6から5秒後に0が出る

```
4 // 関数呼び出しの約1秒後
3 // 上行の約1秒後
2 // 上行の約1秒後
1 // 上行の約1秒後
0 // 上行の約1秒後
COMPLETED // 上行の直後
```

#### 結果

予想通り

```
A
B
C
```

### `i7`

#### 問い

```js
async function i7() {
  // NOTE: i8 との比較用
  let v = 0;

  // 1秒待った後に2秒間隔で value の値を更新
  const p1 = async () => {
    await wait1();
    for (let i = 0; i < 5; i++) {
      const next = v + 1;
      v = next;
      await wait2();
    }
  };

  // 2秒間隔で value の値を更新
  const p2 = async () => {
    for (let i = 0; i < 5; i++) {
      const next = v + 1;
      v = next;
      await wait2();
    }
  };

  await Promise.all([p1(), p2()]);
  log(v);
}
```

#### 予想

`i7()`関数呼び出しから約11秒後に`10`が出力される。

p2, i=0, 関数呼び出し0秒後にv=1
p1, i=0, 関数呼び出し1秒後にv=2
p2, i=1, 関数呼び出し2秒後にv=3
p1, i=1, 関数呼び出し3秒後にv=4
p2, i=2, 関数呼び出し4秒後にv=5
p1, i=2, 関数呼び出し5秒後にv=6
p2, i=3, 関数呼び出し6秒後にv=7
p1, i=3, 関数呼び出し7秒後にv=8
p2, i=4, 関数呼び出し8秒後にv=9
p1, i=4, 関数呼び出し9秒後にv=10

#### 結果

予想通り

### `i8`

#### 問い

```js
async function i8() {
  // NOTE: 複数の非同期処理が1つの変数に対し書き込みを行う場合、読み込みと書き込みの間に await が入るとどうなるだろうか
  let v = 0;

  const p1 = async () => {
    await wait1();
    for (let i = 0; i < 5; i++) {
      // NOTE: value の読み込み (value + 1) と書き込み (value = ...) の間に await が...
      const next = v + 1;
      await wait2();
      v = next;
    }
  };

  const p2 = async () => {
    for (let i = 0; i < 5; i++) {
      const next = v + 1;
      await wait2();
      v = next;
    }
  };

  await Promise.all([p1(), p2()]);
  log(v);
}
```

#### 予想

`i8()`関数呼び出しから約11秒後に`5`が出力される。

p2, i=0, 関数呼び出し0秒後にv=0,関数呼び出し2秒後にv=1
p1, i=0, 関数呼び出し1秒後にv=0,関数呼び出し3秒後にv=1
p2, i=1, 関数呼び出し2秒後にv=1,関数呼び出し4秒後にv=2
p1, i=1, 関数呼び出し3秒後にv=1,関数呼び出し5秒後にv=2
p2, i=2, 関数呼び出し4秒後にv=2,関数呼び出し6秒後にv=3
p1, i=2, 関数呼び出し5秒後にv=2,関数呼び出し7秒後にv=3
p2, i=3, 関数呼び出し6秒後にv=3,関数呼び出し8秒後にv=4
p1, i=3, 関数呼び出し7秒後にv=3,関数呼び出し9秒後にv=4
p2, i=4, 関数呼び出し8秒後にv=4,関数呼び出し10秒後にv=5
p1, i=4, 関数呼び出し9秒後にv=4,関数呼び出し11秒後にv=5

#### 結果

予想通り
