# 答案

## 予想

> `delay` 省略可
> 指定した関数やコードを実行する前に待つタイマーの時間をミリ秒 (1/1000 秒) 単位で指定します。この引数を省略すると値 0 を使用しますので "直ちに" 実行する、より正確に言えばできるだけ早く実行することを意味します。
>
> なお、どちらの場合も、実際の遅延が想定より長くなることがあります。[後述する遅延が指定値より長い理由](https://developer.mozilla.org/ja/docs/Web/API/setTimeout#遅延が指定値より長い理由)をご覧ください。

**後述する遅延が指定値より長い理由**の一例として、

> タイムアウトの遅延
>
> ページ（または OS やブラウザー）が他のタスクでビジー状態場合、タイムアウトが予想より遅れて発生することがあります。注意すべき重要なケースとして、 setTimeout() を呼び出したスレッドが終了するまで、関数やコードスニペットを実行することができないことがあります。

とある。

```js
setTimeout(() => console.log("Hello, world!"), 1000);

function longRunningFunction() {
  while (true) {
    // NOTE: while (true) {} は極端な例であり、現実で見ることは少ないかもしれません。
    // しかし、時間のかかる同期処理を実行して同様の問題が発生することは実際にあります。
  }
}

longRunningFunction();
```

の例では、`setTimeout()`メソッドを呼び出すスレッドが、`setTimeout()`メソッド呼び出し直後に無限ループを実行しているため、1000 ms 経過後もコールバックが呼ばれないものと思われる。

## 結果

`console.log("Hello, world!")`は出力されない。

## 説明

[JavaScript で queueMicrotask() によるマイクロタスクの使用](https://developer.mozilla.org/ja/docs/Web/API/HTML_DOM_API/Microtask_guide)
によると、タスクは以下の場合にキューに追加される。

> タスクは、以下の場合にタスクキューに追加されます。
>
> - 新しい JavaScript プログラムやサブプログラムが（コンソールから、あるいは <script> 要素内のコードを実行して）直接実行されたとき。
> - イベントが発生し、イベントのコールバック関数がタスクキューに追加された場合。
> - setTimeout() または setInterval() で作成したタイムアウトまたはインターバルに達すると、対応するコールバックがタスクキューに追加されます。

今回のケースだと、setTimeout()がタイムアウトに達してコールバックがエンキューされるまえに、無限ループのタスクがエンキューされてしまうため、コールバックが実行されないと説明できる
